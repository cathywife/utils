#!/usr/bin/env python

import os, sys
from subprocess import Popen, PIPE, call, STDOUT

#MACHINES_LIST = os.path.join(os.environ['EPREFIX'], 'etc', 'dsh',
#                             'machines.list')

MACHINES_LIST = '/Users/huoxy/machines'
CLUSTERS_LIST = '.csshrc'

from optparse import OptionParser
parser = OptionParser()
parser.add_option('-a', '--all', action='store_true')
parser.add_option('-m', '--machine')
parser.add_option('-s', '--shortcut')
parser.add_option('-c', '--concurrent', action='store_true')
parser.add_option('-C', '--cluster')
parser.add_option('-t', '--tty', action='store_true')
parser.add_option('-q', '--quiet', action='store_true')
parser.add_option('-l', '--local', action='store_true')
parser.add_option('--sudo', action='store_true')
parser.add_option('--skip-to')
options, args = parser.parse_args()
remote_command = ' '.join(args)

if options.concurrent and options.tty:
    parser.error("--concurrent and --tty are mutual exclusive")
if options.tty and options.sudo:
    parser.error("--tty and --sudo are mutual exclusive")

machines = []
if options.all:
    machines.extend(m.strip() for m in open(MACHINES_LIST)
                    if m and not m.startswith('#'))

if options.machine:
    machines.extend(options.machine.split(','))

if options.cluster:
    for line in open(CLUSTERS_LIST).readlines():
        if line.startswith('%s = ' % options.cluster):
            machines.extend(line.split('=')[1].split())

def get_passwd(machine):
    return ''

failed = False
processes = {}
for i, machine in enumerate(machines):
    if options.local:
        if '**' in remote_command:
            os.system(remote_command.replace('**', machine))
            continue

    if options.skip_to and i < machines.index(options.skip_to):
        continue
    if not options.concurrent and not options.quiet:
        print ">>>>> %s <<<<<" % machine

    cmd = ['ssh', '-tt', machine] if options.tty else ['ssh', machine]
    kwargs = {}

    if options.sudo:
        passwd = get_passwd(machine)
        cmd += ['sudo', '-S', '-H']
        kwargs.update(stdin=PIPE)

    if options.concurrent:
        kwargs.update(stdout=PIPE, stderr=STDOUT, bufsize=1)

    cmd.append(remote_command)

    processes[machine] = p = Popen(cmd, **kwargs)
    if options.sudo:
#        print >>p.stdin, passwd
        p.stdin.flush()

    if not options.concurrent:
        retcode = p.wait()
        if retcode != 0:
            print ">>>>> %s returns %s <<<<<" % (machine, retcode)
            failed = True
            break

if options.concurrent:
    from select import select
    from collections import defaultdict
    output = defaultdict(list)
    retcodes = {}
    while processes:
        rl, wl, xl = select([p.stdout for p in processes.values()], [], [])
        for r in rl:
            machine, process = [(m, p) for m, p in processes.iteritems()
                                if p.stdout==r][0]
            line = r.readline()
            if line:
                if not options.quiet:
                    sys.stdout.write("%s: %s" % (machine, line))
                output[machine].append(line)
            else:
                retcode = process.wait()
                if not options.quiet:
                    print "%s: >>>>> returns %s <<<<<" % (machine, retcode)
                if retcode != 0:
                    failed = True
                retcodes[machine] = retcode
                del processes[machine]

    if options.shortcut == 'loadtop':
        import re
        host_loads = []
        RE_LOAD5 = re.compile('load average:\s([^,]+)')
        for host, uptime in output.items():
            load5 = float(RE_LOAD5.findall(uptime[0])[0])
            host_loads.append((load5, host))
        for load, host in sorted(host_loads, reverse=True):
            print '%-20s%.2f' % (host, load)
        sys.exit(0)

    print
    print "==================================="
    print

    for m in machines:
        print '>>>>> %s <<<<<' % m
        for line in output[m]:
            sys.stdout.write(line)
        print '>>>>> %s returns %s <<<<<' % (m, retcodes[m])
        print
        print "-----------------------------------"

    print
    notokay = {}
    okay = {}
    for host, code in retcodes.items():
        if code != 0:
            notokay[host] = code
        else:
            okay[host] = code
    okay_count = len(retcodes) - len(notokay)
    print '%s hosts in total, %s are okay.' % (len(retcodes), okay_count)
    if okay_count:
        print 'There hosts are okay:'
        for m, code in okay.items():
            print '%s: %s' % (m, code)
    if okay_count != len(retcodes):
        print 'There is something wrong with these hosts:'
        for m, code in notokay.items():
            print '%s: %s' % (m, code)

sys.exit(1 if failed else 0)
